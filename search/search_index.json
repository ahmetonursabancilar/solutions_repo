{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Theoretical Foundation of Projectile Motion Derivation of Governing Equations Projectile motion can be described by decomposing the motion into horizontal and vertical components. The motion follows Newton\u2019s second law of motion: \\[F = ma\\] For a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , the velocity components are: $$ v_{0x} = v_0 \\cos\\theta $$ $$ v_{0y} = v_0 \\sin\\theta $$ Assuming constant gravitational acceleration \\(g\\) acting downward, the equations of motion arise from Newton\u2019s second law: Horizontal Motion: Since there is no acceleration in the horizontal direction (neglecting air resistance), the equation of motion simplifies to: \\[\\frac{d^2x}{dt^2} = 0\\] Integrating twice gives: \\[x(t) = v_0 \\cos\\theta \\cdot t\\] Vertical Motion: The vertical motion follows: \\[\\frac{d^2y}{dt^2} = -g\\] Integrating once: \\[\\frac{dy}{dt} = v_0 \\sin\\theta - g t\\] Integrating again: \\[y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Time of Flight To determine the total time the projectile remains in the air, we set \\(y = 0\\) (assuming launch and landing at the same height): \\[0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Solving for \\(t\\) : \\[t = \\frac{2 v_0 \\sin\\theta}{g}\\] Range of the Projectile The horizontal range \\(R\\) is found by substituting the time of flight into the horizontal motion equation: \\[R = v_{0x} t\\] \\[R = (v_0 \\cos\\theta) \\times \\frac{2 v_0 \\sin\\theta}{g}\\] Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\] Effect of Launch Angle on Range The range equation shows that \\(R\\) depends on \\(\\sin 2\\theta\\) . The maximum range occurs when \\(\\sin 2\\theta = 1\\) , which happens at \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Therefore, the optimal launch angle for maximum range is 45 degrees . Influence of Initial Conditions Several factors influence the projectile\u2019s trajectory: Initial Velocity \\(v_0\\) : Higher speeds result in a longer range. Gravitational Acceleration \\(g\\) : Increased gravity shortens the range. Launch Angle \\(\\theta\\) : Different angles yield different parabolic trajectories, with 45\u00b0 providing maximum range. Launch Height : If the projectile starts from a height \\(h\\) , the time of flight increases, thereby affecting the range. Investigation of Horizontal Range Dependence Dependence on Angle of Projection From the range equation: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\] The function \\(\\sin 2\\theta\\) dictates how \\(R\\) varies with angle. \\(R\\) increases as \\(\\theta\\) moves from 0\u00b0 to 45\u00b0 and decreases thereafter up to 90\u00b0. This symmetric behavior results in the same range for complementary angles (e.g., 30\u00b0 and 60\u00b0). Effect of Other Parameters Initial Velocity ( \\(v_0\\) ) : Since range is proportional to \\(v_0^2\\) , doubling the velocity quadruples the range. Gravitational Acceleration ( \\(g\\) ) : Range is inversely proportional to \\(g\\) , meaning that stronger gravity (such as on Jupiter) reduces range, while weaker gravity (such as on the Moon) increases range. Launch Height ( \\(h\\) ) : An increased launch height extends the flight time, thereby increasing the range. Family of Solutions By varying initial conditions, a family of parabolic trajectories emerges: - Different launch angles create different paths, with the same range for complementary angles. - Different initial velocities scale the trajectory while maintaining its shape. - Different gravitational accelerations alter both the height and range. - Different launch heights modify the total flight time and final landing position. Practical Applications Projectile motion applies to numerous real-world scenarios, where additional factors such as air resistance and uneven terrain must be considered. Some key applications include: Ballistics : Predicting the trajectory of bullets, missiles, and artillery shells requires accounting for air drag and wind resistance. Sports Science : Understanding projectile motion helps optimize techniques in sports like soccer, basketball, and golf. Engineering and Construction : Calculating the paths of thrown objects or designing safe trajectories for cranes and demolition projects. Space Exploration : Modeling the launch and re-entry paths of rockets and satellites, where varying gravitational fields must be factored in. Environmental Studies : Studying volcanic eruptions, landslides, and debris flows to predict impact zones and mitigate damage. In these cases, computational models incorporating additional forces, such as drag and lift, refine the accuracy of projectile predictions. Implementation Computational Simulation of Projectile Motion Developing a computational tool allows for precise analysis of projectile motion under varying conditions. A basic algorithm for simulating projectile motion follows these steps: Initialize Parameters : Define initial velocity \\(v_0\\) , launch angle \\(\\theta\\) , gravitational acceleration \\(g\\) , and time step \\(\\Delta t\\) . Calculate Components : Compute horizontal and vertical velocity components. Iterate Motion : Update position and velocity using kinematic equations at small time steps. Plot Trajectory : Visualize the projectile\u2019s path using computational tools such as Python (Matplotlib) or MATLAB. Analyze Variations : Generate plots of range as a function of launch angle for different velocities and gravitational conditions. Such simulations help in educational demonstrations, research, and engineering applications where precise trajectory predictions are required. Implementation 1 Computational Simulation of Projectile Motion To analyze projectile motion computationally, we implement a numerical simulation. The following Python script: \u2705 Simulates the motion of a projectile for different launch angles. \u2705 Plots the trajectory of the projectile. \u2705 Visualizes range vs launch angle to analyze how the angle affects the range. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 10) # Angles from 0\u00b0 to 90\u00b0 # Function to compute projectile trajectory def projectile_trajectory(v0, theta, g): theta_rad = np.radians(theta) # Convert to radians vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Time of flight t_flight = 2 * vy / g t = np.linspace(0, t_flight, num=100) # Compute x and y coordinates x = vx * t y = vy * t - 0.5 * g * t**2 return x, y # Plot projectile trajectories for different angles plt.figure(figsize=(10, 5)) for angle in angles: x, y = projectile_trajectory(v0, angle, g) plt.plot(x, y, label=f'{int(angle)}\u00b0') plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion for Different Angles\") plt.legend() plt.grid(True) plt.show() # Compute and plot range vs angle ranges = [(v0**2 * np.sin(2 * np.radians(angle))) / g for angle in angles] plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, 'bo-', label=\"Range\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Range vs Launch Angle\") plt.legend() plt.grid(True) plt.show() Interpretation of Results Projectile Trajectories for Different Angles The first plot shows how the path of the projectile changes with the launch angle. Lower angles result in longer but lower trajectories, while higher angles make the projectile reach greater heights but shorter distances. The optimal trajectory for maximum range appears near 45\u00b0 , confirming the theoretical prediction. Range vs Launch Angle Graph The second plot demonstrates the relationship between range and launch angle . The range is maximum at 45\u00b0 and symmetric for complementary angles (e.g., 30\u00b0 and 60\u00b0 yield the same range ). This confirms that the optimal launch angle for maximum horizontal distance in ideal conditions is 45\u00b0 . Limitations & Real-World Considerations This model neglects air resistance , which in reality reduces range . Uneven terrain or variable gravity (e.g., Moon vs Earth) can alter the motion. Wind and drag forces significantly affect projectiles in sports and ballistics. More advanced simulations incorporate fluid dynamics for real-world accuracy. Implementation 2: Simulating Projectile Motion To visualize how projectile motion changes with different initial velocities, we implemented a Python script that simulates the motion of a projectile launched at 45\u00b0 with three different speeds: 30, 40, and 50 m/s . Key Observations: Higher initial velocity results in a longer range and greater peak height while maintaining the same parabolic trajectory shape. The motion follows the equations derived earlier, confirming that the range is proportional to the square of velocity . The graph clearly demonstrates how projectiles with different speeds travel varying distances while following a predictable arc. This computational model allows for further analysis, such as exploring different angles, gravitational effects, and real-world factors like air resistance. import numpy as np import matplotlib.pyplot as plt def plot_projectile(v0_values, theta=45, g=9.81, dt=0.01): plt.figure(figsize=(8, 6)) for v0 in v0_values: theta_rad = np.radians(theta) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) t_max = 2 * vy / g # Total flight time t = np.arange(0, t_max, dt) x = vx * t y = vy * t - 0.5 * g * t**2 plt.plot(x, y, label=f\"v0 = {v0} m/s\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Motion for {theta}\u00b0 with Different Initial Velocities\") plt.legend() plt.grid() plt.show() # Run simulation for initial velocities 30, 40, and 50 m/s plot_projectile([30, 40, 50]) Here's how you can incorporate this code and explanation into your presentation: Implementation 3: Comparison of Projectile Motion: With and Without Air Resistance The following plot compares projectile motion with and without air resistance. The simulation uses a launch angle of 45\u00b0 and an initial velocity of 50 m/s. Python Code to Simulate Projectile Motion with and Without Air Resistance: import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_air_resistance(v0, angle, g=9.81, dt=0.01, air_resistance=True): # Constants mass = 1.0 # Mass of the projectile in kg (assumed) drag_coefficient = 0.47 # Drag coefficient for a sphere (approx) radius = 0.1 # Radius of the projectile (in meters) area = np.pi * radius**2 # Cross-sectional area (m^2) air_density = 1.225 # Air density at sea level (kg/m^3) # Initial conditions theta_rad = np.radians(angle) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Initial position x, y = 0, 0 # Lists to store the position data x_vals, y_vals = [x], [y] # Air resistance calculations if air_resistance: drag_force = lambda v: 0.5 * air_density * area * drag_coefficient * v**2 else: drag_force = lambda v: 0 # No drag force # Time of flight estimation while y >= 0: speed = np.sqrt(vx**2 + vy**2) # Calculate drag force if air resistance is considered drag_x = drag_force(speed) * (vx / speed) if air_resistance else 0 drag_y = drag_force(speed) * (vy / speed) if air_resistance else 0 # Accelerations ax = -drag_x / mass ay = -g - drag_y / mass # Update velocities vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt # Store positions x_vals.append(x) y_vals.append(y) return x_vals, y_vals # Parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) # Plot projectile motion with and without air resistance plt.figure(figsize=(8, 6)) # Plot with air resistance x_vals_with_air, y_vals_with_air = projectile_motion_with_air_resistance(v0, angle, air_resistance=True) plt.plot(x_vals_with_air, y_vals_with_air, label=\"With Air Resistance\", color='blue') # Plot without air resistance x_vals_without_air, y_vals_without_air = projectile_motion_with_air_resistance(v0, angle, air_resistance=False) plt.plot(x_vals_without_air, y_vals_without_air, label=\"Without Air Resistance\", color='red', linestyle='--') # Adding labels and title plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion: With and Without Air Resistance\") plt.legend() plt.grid(True) plt.show() Explanation of the Plot: Blue Line: Represents the projectile trajectory when air resistance is taken into account. Notice how the range is shorter and the maximum height is reduced compared to the ideal case. Red Dashed Line: Represents the idealized trajectory assuming no air resistance . This is the parabolic motion we commonly study in basic physics. Key Insights: Air Resistance: In real-world scenarios, air resistance causes the projectile to decelerate more quickly, reducing both its range and maximum height. Idealized Model: The absence of air resistance results in a larger range and higher trajectory, which is what we see in an idealized situation without drag forces. Conclusion: Projectile motion is a foundational concept in physics, with applications spanning from sports to engineering and space exploration. While the idealized model of projectile motion provides a clear understanding of the relationship between launch angle, initial velocity, and range, real-world factors like air resistance and varying terrain complicate these trajectories. Computational models, such as the one presented here, allow for more accurate predictions by incorporating these additional forces, thus enhancing our ability to model and optimize projectile motion in practical scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation-of-projectile-motion","text":"","title":"Theoretical Foundation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations","text":"Projectile motion can be described by decomposing the motion into horizontal and vertical components. The motion follows Newton\u2019s second law of motion: \\[F = ma\\] For a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) , the velocity components are: $$ v_{0x} = v_0 \\cos\\theta $$ $$ v_{0y} = v_0 \\sin\\theta $$ Assuming constant gravitational acceleration \\(g\\) acting downward, the equations of motion arise from Newton\u2019s second law:","title":"Derivation of Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Since there is no acceleration in the horizontal direction (neglecting air resistance), the equation of motion simplifies to: \\[\\frac{d^2x}{dt^2} = 0\\] Integrating twice gives: \\[x(t) = v_0 \\cos\\theta \\cdot t\\]","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion follows: \\[\\frac{d^2y}{dt^2} = -g\\] Integrating once: \\[\\frac{dy}{dt} = v_0 \\sin\\theta - g t\\] Integrating again: \\[y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\]","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"To determine the total time the projectile remains in the air, we set \\(y = 0\\) (assuming launch and landing at the same height): \\[0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Solving for \\(t\\) : \\[t = \\frac{2 v_0 \\sin\\theta}{g}\\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The horizontal range \\(R\\) is found by substituting the time of flight into the horizontal motion equation: \\[R = v_{0x} t\\] \\[R = (v_0 \\cos\\theta) \\times \\frac{2 v_0 \\sin\\theta}{g}\\] Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\]","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-launch-angle-on-range","text":"The range equation shows that \\(R\\) depends on \\(\\sin 2\\theta\\) . The maximum range occurs when \\(\\sin 2\\theta = 1\\) , which happens at \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Therefore, the optimal launch angle for maximum range is 45 degrees .","title":"Effect of Launch Angle on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","text":"Several factors influence the projectile\u2019s trajectory: Initial Velocity \\(v_0\\) : Higher speeds result in a longer range. Gravitational Acceleration \\(g\\) : Increased gravity shortens the range. Launch Angle \\(\\theta\\) : Different angles yield different parabolic trajectories, with 45\u00b0 providing maximum range. Launch Height : If the projectile starts from a height \\(h\\) , the time of flight increases, thereby affecting the range. Investigation of Horizontal Range Dependence","title":"Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle-of-projection","text":"From the range equation: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\] The function \\(\\sin 2\\theta\\) dictates how \\(R\\) varies with angle. \\(R\\) increases as \\(\\theta\\) moves from 0\u00b0 to 45\u00b0 and decreases thereafter up to 90\u00b0. This symmetric behavior results in the same range for complementary angles (e.g., 30\u00b0 and 60\u00b0).","title":"Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-other-parameters","text":"Initial Velocity ( \\(v_0\\) ) : Since range is proportional to \\(v_0^2\\) , doubling the velocity quadruples the range. Gravitational Acceleration ( \\(g\\) ) : Range is inversely proportional to \\(g\\) , meaning that stronger gravity (such as on Jupiter) reduces range, while weaker gravity (such as on the Moon) increases range. Launch Height ( \\(h\\) ) : An increased launch height extends the flight time, thereby increasing the range. Family of Solutions By varying initial conditions, a family of parabolic trajectories emerges: - Different launch angles create different paths, with the same range for complementary angles. - Different initial velocities scale the trajectory while maintaining its shape. - Different gravitational accelerations alter both the height and range. - Different launch heights modify the total flight time and final landing position.","title":"Effect of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"Projectile motion applies to numerous real-world scenarios, where additional factors such as air resistance and uneven terrain must be considered. Some key applications include: Ballistics : Predicting the trajectory of bullets, missiles, and artillery shells requires accounting for air drag and wind resistance. Sports Science : Understanding projectile motion helps optimize techniques in sports like soccer, basketball, and golf. Engineering and Construction : Calculating the paths of thrown objects or designing safe trajectories for cranes and demolition projects. Space Exploration : Modeling the launch and re-entry paths of rockets and satellites, where varying gravitational fields must be factored in. Environmental Studies : Studying volcanic eruptions, landslides, and debris flows to predict impact zones and mitigate damage. In these cases, computational models incorporating additional forces, such as drag and lift, refine the accuracy of projectile predictions.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-simulation-of-projectile-motion","text":"Developing a computational tool allows for precise analysis of projectile motion under varying conditions. A basic algorithm for simulating projectile motion follows these steps: Initialize Parameters : Define initial velocity \\(v_0\\) , launch angle \\(\\theta\\) , gravitational acceleration \\(g\\) , and time step \\(\\Delta t\\) . Calculate Components : Compute horizontal and vertical velocity components. Iterate Motion : Update position and velocity using kinematic equations at small time steps. Plot Trajectory : Visualize the projectile\u2019s path using computational tools such as Python (Matplotlib) or MATLAB. Analyze Variations : Generate plots of range as a function of launch angle for different velocities and gravitational conditions. Such simulations help in educational demonstrations, research, and engineering applications where precise trajectory predictions are required.","title":"Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-1","text":"","title":"Implementation 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-simulation-of-projectile-motion_1","text":"To analyze projectile motion computationally, we implement a numerical simulation. The following Python script: \u2705 Simulates the motion of a projectile for different launch angles. \u2705 Plots the trajectory of the projectile. \u2705 Visualizes range vs launch angle to analyze how the angle affects the range.","title":"Computational Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 10) # Angles from 0\u00b0 to 90\u00b0 # Function to compute projectile trajectory def projectile_trajectory(v0, theta, g): theta_rad = np.radians(theta) # Convert to radians vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Time of flight t_flight = 2 * vy / g t = np.linspace(0, t_flight, num=100) # Compute x and y coordinates x = vx * t y = vy * t - 0.5 * g * t**2 return x, y # Plot projectile trajectories for different angles plt.figure(figsize=(10, 5)) for angle in angles: x, y = projectile_trajectory(v0, angle, g) plt.plot(x, y, label=f'{int(angle)}\u00b0') plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion for Different Angles\") plt.legend() plt.grid(True) plt.show() # Compute and plot range vs angle ranges = [(v0**2 * np.sin(2 * np.radians(angle))) / g for angle in angles] plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, 'bo-', label=\"Range\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Range vs Launch Angle\") plt.legend() plt.grid(True) plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#interpretation-of-results","text":"Projectile Trajectories for Different Angles The first plot shows how the path of the projectile changes with the launch angle. Lower angles result in longer but lower trajectories, while higher angles make the projectile reach greater heights but shorter distances. The optimal trajectory for maximum range appears near 45\u00b0 , confirming the theoretical prediction. Range vs Launch Angle Graph The second plot demonstrates the relationship between range and launch angle . The range is maximum at 45\u00b0 and symmetric for complementary angles (e.g., 30\u00b0 and 60\u00b0 yield the same range ). This confirms that the optimal launch angle for maximum horizontal distance in ideal conditions is 45\u00b0 .","title":"Interpretation of Results"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-real-world-considerations","text":"This model neglects air resistance , which in reality reduces range . Uneven terrain or variable gravity (e.g., Moon vs Earth) can alter the motion. Wind and drag forces significantly affect projectiles in sports and ballistics. More advanced simulations incorporate fluid dynamics for real-world accuracy.","title":"Limitations &amp; Real-World Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-2-simulating-projectile-motion","text":"To visualize how projectile motion changes with different initial velocities, we implemented a Python script that simulates the motion of a projectile launched at 45\u00b0 with three different speeds: 30, 40, and 50 m/s .","title":"Implementation 2: Simulating Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Higher initial velocity results in a longer range and greater peak height while maintaining the same parabolic trajectory shape. The motion follows the equations derived earlier, confirming that the range is proportional to the square of velocity . The graph clearly demonstrates how projectiles with different speeds travel varying distances while following a predictable arc. This computational model allows for further analysis, such as exploring different angles, gravitational effects, and real-world factors like air resistance. import numpy as np import matplotlib.pyplot as plt def plot_projectile(v0_values, theta=45, g=9.81, dt=0.01): plt.figure(figsize=(8, 6)) for v0 in v0_values: theta_rad = np.radians(theta) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) t_max = 2 * vy / g # Total flight time t = np.arange(0, t_max, dt) x = vx * t y = vy * t - 0.5 * g * t**2 plt.plot(x, y, label=f\"v0 = {v0} m/s\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(f\"Projectile Motion for {theta}\u00b0 with Different Initial Velocities\") plt.legend() plt.grid() plt.show() # Run simulation for initial velocities 30, 40, and 50 m/s plot_projectile([30, 40, 50]) Here's how you can incorporate this code and explanation into your presentation:","title":"Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-3-comparison-of-projectile-motion-with-and-without-air-resistance","text":"The following plot compares projectile motion with and without air resistance. The simulation uses a launch angle of 45\u00b0 and an initial velocity of 50 m/s.","title":"Implementation 3: Comparison of Projectile Motion: With and Without Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-to-simulate-projectile-motion-with-and-without-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt def projectile_motion_with_air_resistance(v0, angle, g=9.81, dt=0.01, air_resistance=True): # Constants mass = 1.0 # Mass of the projectile in kg (assumed) drag_coefficient = 0.47 # Drag coefficient for a sphere (approx) radius = 0.1 # Radius of the projectile (in meters) area = np.pi * radius**2 # Cross-sectional area (m^2) air_density = 1.225 # Air density at sea level (kg/m^3) # Initial conditions theta_rad = np.radians(angle) vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Initial position x, y = 0, 0 # Lists to store the position data x_vals, y_vals = [x], [y] # Air resistance calculations if air_resistance: drag_force = lambda v: 0.5 * air_density * area * drag_coefficient * v**2 else: drag_force = lambda v: 0 # No drag force # Time of flight estimation while y >= 0: speed = np.sqrt(vx**2 + vy**2) # Calculate drag force if air resistance is considered drag_x = drag_force(speed) * (vx / speed) if air_resistance else 0 drag_y = drag_force(speed) * (vy / speed) if air_resistance else 0 # Accelerations ax = -drag_x / mass ay = -g - drag_y / mass # Update velocities vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt # Store positions x_vals.append(x) y_vals.append(y) return x_vals, y_vals # Parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) # Plot projectile motion with and without air resistance plt.figure(figsize=(8, 6)) # Plot with air resistance x_vals_with_air, y_vals_with_air = projectile_motion_with_air_resistance(v0, angle, air_resistance=True) plt.plot(x_vals_with_air, y_vals_with_air, label=\"With Air Resistance\", color='blue') # Plot without air resistance x_vals_without_air, y_vals_without_air = projectile_motion_with_air_resistance(v0, angle, air_resistance=False) plt.plot(x_vals_without_air, y_vals_without_air, label=\"Without Air Resistance\", color='red', linestyle='--') # Adding labels and title plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion: With and Without Air Resistance\") plt.legend() plt.grid(True) plt.show()","title":"Python Code to Simulate Projectile Motion with and Without Air Resistance:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-plot","text":"Blue Line: Represents the projectile trajectory when air resistance is taken into account. Notice how the range is shorter and the maximum height is reduced compared to the ideal case. Red Dashed Line: Represents the idealized trajectory assuming no air resistance . This is the parabolic motion we commonly study in basic physics.","title":"Explanation of the Plot:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-insights","text":"Air Resistance: In real-world scenarios, air resistance causes the projectile to decelerate more quickly, reducing both its range and maximum height. Idealized Model: The absence of air resistance results in a larger range and higher trajectory, which is what we see in an idealized situation without drag forces. Conclusion: Projectile motion is a foundational concept in physics, with applications spanning from sports to engineering and space exploration. While the idealized model of projectile motion provides a clear understanding of the relationship between launch angle, initial velocity, and range, real-world factors like air resistance and varying terrain complicate these trajectories. Computational models, such as the one presented here, allow for more accurate predictions by incorporating these additional forces, thus enhancing our ability to model and optimize projectile motion in practical scenarios.","title":"Key Insights:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"\ud83c\udfa2 Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Motivation The forced damped pendulum is not just another mechanical system\u2014 it's a gateway into the world of complex, nonlinear dynamics . When damping and a periodic driving force are both present, something magical happens: a simple swing turns into a playground of resonance, chaos, and quasiperiodicity . This makes the system a powerful analogy for real-world phenomena like: Climate cycles \ud83c\udf0d Vibrating bridges \ud83c\udf09 Electrical circuits \u26a1 So why study this? Because understanding how a simple pendulum behaves under stress tells us how complex systems thrive\u2014or fail \u2014in the face of repeated forces. \ud83e\udde0 1. Theoretical Foundation Let\u2019s start from the fundamental equation that governs the motion: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(\\gamma\\) : Damping coefficient - \\(\\omega_0\\) : Natural frequency - \\(A\\) : Driving force amplitude - \\(\\omega\\) : Driving frequency \u270f\ufe0f Small-Angle Approximation When the angle is small \\((\\theta \\ll 1)\\) , we simplify: \\[ \\sin(\\theta) \\approx \\theta \\] Which gives: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This version is linear and lets us dig into analytical solutions. \ud83d\udd0d General Solution The full solution is the sum of: Homogeneous (transient) part Particular (steady-state) part Transient part: \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right) \\] Where: \\[ \\Omega = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\] Steady-state part: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] Amplitude and phase shift are: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}, \\quad \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\] \ud83d\udcc8 Resonance: The Sweet Spot of Energy Resonance happens when the system absorbs maximum energy from the driving force: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] Here, even small forces can cause large-amplitude oscillations. This is where beauty meets danger in mechanical systems! \ud83c\udf00 2. Analysis of Dynamics \ud83c\udf9b\ufe0f Parameter Effects Let\u2019s see how changing different parameters affects motion: Damping ( \\(\\gamma\\) ) : High \u2192 suppresses motion Low \u2192 enables oscillation and even chaos Driving amplitude ( \\(A\\) ) : Low \u2192 simple periodic motion High \u2192 system may go chaotic Driving frequency ( \\(\\omega\\) ) : Near \\(\\omega_0\\) \u2192 resonance! Far \u2192 low amplitude \u26a0\ufe0f From Order to Chaos As you tweak \\(A\\) or \\(\\omega\\) , the system transitions like this: Simple periodic motion Quasiperiodic motion Period-doubling Chaos \ud83d\udea8 Visualize this with: - Phase space plots \\((\\theta \\text{ vs } \\dot{\\theta})\\) - Poincar\u00e9 sections : snapshot once per cycle - Bifurcation diagrams : to see chaos emerge! \u2699\ufe0f 3. Real-World Applications This isn't just theory\u2014it shows up in real life: \ud83e\uddf2 Energy Harvesting : Tiny vibrations \u2192 electricity (like in wearables or smart bridges) \ud83c\udf09 Suspension Bridges : Unchecked resonance can cause catastrophic failure (hello, Tacoma Narrows Bridge...) \u26a1 Oscillating Circuits : The pendulum\u2019s math is mirrored in RLC circuits with AC driving. \ud83d\ude80 Wrap-Up The forced damped pendulum is more than a swinging weight\u2014 it's a model for complexity, transition, and control . Whether you're an engineer, physicist, or just someone who likes watching the world wiggle into chaos\u2014this system's got something for you. \ud83d\udd27 4. Implementation: Computational Model \ud83d\udee0\ufe0f Common Setup (Run This First) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum equation def pendulum_eq(t, y, gamma, omega0, A, omega_drive): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, dtheta_dot_dt] # Plotting functions def plot_time_series(sol, title): plt.figure(figsize=(10, 3.5)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('\u03b8 (rad)') plt.title(title) plt.grid(True) plt.tight_layout() plt.show() def plot_phase_diagram(sol, title): plt.figure(figsize=(5, 5)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03b8\u0307 (rad/s)') plt.title(title) plt.grid(True) plt.tight_layout() plt.show() 1\ufe0f\u20e3 Simple Pendulum # Parameters gamma = 0.0 A = 0.0 omega0 = 2.0 omega_drive = 0.0 # Not used since A = 0 # Initial conditions and simulation y0 = [0.2, 0.0] t_eval = np.linspace(0, 20, 1000) sol = solve_ivp(pendulum_eq, (0, 20), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plots plot_time_series(sol, \"Simple Pendulum: \u03b8(t)\") plot_phase_diagram(sol, \"Simple Pendulum: Phase Diagram\") \u03b8(t) Plot: The pendulum oscillates in a regular, periodic motion without any energy loss. This is the ideal, undamped case. Phase Diagram: Closed elliptical loops indicate conserved energy and perfect periodic behavior. 2\ufe0f\u20e3 Damped Pendulum gamma = 0.2 A = 0.0 omega0 = 2.0 omega_drive = 0.0 y0 = [0.2, 0.0] t_eval = np.linspace(0, 20, 1000) sol = solve_ivp(pendulum_eq, (0, 20), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Damped Pendulum: \u03b8(t)\") plot_phase_diagram(sol, \"Damped Pendulum: Phase Diagram\") \u03b8(t) Plot: The oscillations decay over time as energy is gradually lost due to damping. The system approaches equilibrium. Phase Diagram: A spiral trajectory converging to the origin, showing the loss of kinetic and potential energy. 3\ufe0f\u20e3 Forced Pendulum (No Damping) gamma = 0.0 A = 1.0 omega0 = 2.0 omega_drive = 1.5 y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Pendulum (No Damping): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Pendulum (No Damping): Phase Diagram\") \u03b8(t) Plot: Continuous external forcing causes sustained oscillations. The amplitude can vary depending on resonance. Phase Diagram: Complex loops reflect the interplay between the natural frequency and driving force \u2014 no energy is lost. 4\ufe0f\u20e3 Forced Damped Pendulum \u2013 Scenario 1 (Moderate Forcing) gamma = 0.2 A = 1.2 omega0 = 2.0 omega_drive = 2.0 y0 = [0.1, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Damped Pendulum (Scenario 1): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Damped Pendulum (Scenario 1): Phase Diagram\") \u03b8(t) Plot: The system reaches a steady oscillatory state after initial transients. Oscillations are periodic but limited by damping. Phase Diagram: A stable closed loop (limit cycle), indicating periodic motion with energy input balancing damping. 5\ufe0f\u20e3 Forced Damped Pendulum \u2013 Scenario 2 (Stronger Forcing) gamma = 0.2 A = 1.5 omega0 = 2.0 omega_drive = 1.0 y0 = [0.1, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Damped Pendulum (Scenario 2): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Damped Pendulum (Scenario 2): Phase Diagram\") \u03b8(t) Plot: The system shows irregular or chaotic behavior due to stronger forcing or off-resonance driving. Phase Diagram: The scattered points or tangled trajectories suggest sensitive dependence on initial conditions \u2014 a sign of chaos. \ud83c\udfaf Conclusion The forced damped pendulum serves as a powerful model for understanding the rich and complex behavior of nonlinear dynamical systems. Through theoretical analysis and computational simulations, we have demonstrated how variations in damping, driving amplitude, and frequency can lead to a wide range of phenomena \u2014 from regular oscillations to chaotic motion. Our exploration highlights the sensitivity of the system to initial conditions and parameter changes, illustrating concepts like resonance and the transition to chaos. Tools such as phase diagrams and Poincar\u00e9 sections proved essential in visualizing and interpreting these dynamics. Beyond its theoretical importance, the forced damped pendulum has practical relevance in engineering, physics, and even biological systems. This study reinforces the value of combining analytical insights with computational tools to explore and understand the nonlinear world.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udfa2 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is not just another mechanical system\u2014 it's a gateway into the world of complex, nonlinear dynamics . When damping and a periodic driving force are both present, something magical happens: a simple swing turns into a playground of resonance, chaos, and quasiperiodicity . This makes the system a powerful analogy for real-world phenomena like: Climate cycles \ud83c\udf0d Vibrating bridges \ud83c\udf09 Electrical circuits \u26a1 So why study this? Because understanding how a simple pendulum behaves under stress tells us how complex systems thrive\u2014or fail \u2014in the face of repeated forces.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Let\u2019s start from the fundamental equation that governs the motion: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : Angular displacement - \\(\\gamma\\) : Damping coefficient - \\(\\omega_0\\) : Natural frequency - \\(A\\) : Driving force amplitude - \\(\\omega\\) : Driving frequency","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When the angle is small \\((\\theta \\ll 1)\\) , we simplify: \\[ \\sin(\\theta) \\approx \\theta \\] Which gives: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This version is linear and lets us dig into analytical solutions.","title":"\u270f\ufe0f Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution","text":"The full solution is the sum of: Homogeneous (transient) part Particular (steady-state) part Transient part: \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{\\gamma}{2} t} \\left( C_1 \\cos(\\Omega t) + C_2 \\sin(\\Omega t) \\right) \\] Where: \\[ \\Omega = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\] Steady-state part: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] Amplitude and phase shift are: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}, \\quad \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\]","title":"\ud83d\udd0d General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-the-sweet-spot-of-energy","text":"Resonance happens when the system absorbs maximum energy from the driving force: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] Here, even small forces can cause large-amplitude oscillations. This is where beauty meets danger in mechanical systems!","title":"\ud83d\udcc8 Resonance: The Sweet Spot of Energy"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83c\udf00 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-effects","text":"Let\u2019s see how changing different parameters affects motion: Damping ( \\(\\gamma\\) ) : High \u2192 suppresses motion Low \u2192 enables oscillation and even chaos Driving amplitude ( \\(A\\) ) : Low \u2192 simple periodic motion High \u2192 system may go chaotic Driving frequency ( \\(\\omega\\) ) : Near \\(\\omega_0\\) \u2192 resonance! Far \u2192 low amplitude","title":"\ud83c\udf9b\ufe0f Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#from-order-to-chaos","text":"As you tweak \\(A\\) or \\(\\omega\\) , the system transitions like this: Simple periodic motion Quasiperiodic motion Period-doubling Chaos \ud83d\udea8 Visualize this with: - Phase space plots \\((\\theta \\text{ vs } \\dot{\\theta})\\) - Poincar\u00e9 sections : snapshot once per cycle - Bifurcation diagrams : to see chaos emerge!","title":"\u26a0\ufe0f From Order to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"This isn't just theory\u2014it shows up in real life: \ud83e\uddf2 Energy Harvesting : Tiny vibrations \u2192 electricity (like in wearables or smart bridges) \ud83c\udf09 Suspension Bridges : Unchecked resonance can cause catastrophic failure (hello, Tacoma Narrows Bridge...) \u26a1 Oscillating Circuits : The pendulum\u2019s math is mirrored in RLC circuits with AC driving.","title":"\u2699\ufe0f 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#wrap-up","text":"The forced damped pendulum is more than a swinging weight\u2014 it's a model for complexity, transition, and control . Whether you're an engineer, physicist, or just someone who likes watching the world wiggle into chaos\u2014this system's got something for you.","title":"\ud83d\ude80 Wrap-Up"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-computational-model","text":"","title":"\ud83d\udd27 4. Implementation: Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#common-setup-run-this-first","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum equation def pendulum_eq(t, y, gamma, omega0, A, omega_drive): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, dtheta_dot_dt] # Plotting functions def plot_time_series(sol, title): plt.figure(figsize=(10, 3.5)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('\u03b8 (rad)') plt.title(title) plt.grid(True) plt.tight_layout() plt.show() def plot_phase_diagram(sol, title): plt.figure(figsize=(5, 5)) plt.plot(sol.y[0], sol.y[1], lw=0.8) plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03b8\u0307 (rad/s)') plt.title(title) plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udee0\ufe0f Common Setup (Run This First)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-simple-pendulum","text":"# Parameters gamma = 0.0 A = 0.0 omega0 = 2.0 omega_drive = 0.0 # Not used since A = 0 # Initial conditions and simulation y0 = [0.2, 0.0] t_eval = np.linspace(0, 20, 1000) sol = solve_ivp(pendulum_eq, (0, 20), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plots plot_time_series(sol, \"Simple Pendulum: \u03b8(t)\") plot_phase_diagram(sol, \"Simple Pendulum: Phase Diagram\") \u03b8(t) Plot: The pendulum oscillates in a regular, periodic motion without any energy loss. This is the ideal, undamped case. Phase Diagram: Closed elliptical loops indicate conserved energy and perfect periodic behavior.","title":"1\ufe0f\u20e3 Simple Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-damped-pendulum","text":"gamma = 0.2 A = 0.0 omega0 = 2.0 omega_drive = 0.0 y0 = [0.2, 0.0] t_eval = np.linspace(0, 20, 1000) sol = solve_ivp(pendulum_eq, (0, 20), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Damped Pendulum: \u03b8(t)\") plot_phase_diagram(sol, \"Damped Pendulum: Phase Diagram\") \u03b8(t) Plot: The oscillations decay over time as energy is gradually lost due to damping. The system approaches equilibrium. Phase Diagram: A spiral trajectory converging to the origin, showing the loss of kinetic and potential energy.","title":"2\ufe0f\u20e3 Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-forced-pendulum-no-damping","text":"gamma = 0.0 A = 1.0 omega0 = 2.0 omega_drive = 1.5 y0 = [0.2, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Pendulum (No Damping): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Pendulum (No Damping): Phase Diagram\") \u03b8(t) Plot: Continuous external forcing causes sustained oscillations. The amplitude can vary depending on resonance. Phase Diagram: Complex loops reflect the interplay between the natural frequency and driving force \u2014 no energy is lost.","title":"3\ufe0f\u20e3 Forced Pendulum (No Damping)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-forced-damped-pendulum-scenario-1-moderate-forcing","text":"gamma = 0.2 A = 1.2 omega0 = 2.0 omega_drive = 2.0 y0 = [0.1, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Damped Pendulum (Scenario 1): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Damped Pendulum (Scenario 1): Phase Diagram\") \u03b8(t) Plot: The system reaches a steady oscillatory state after initial transients. Oscillations are periodic but limited by damping. Phase Diagram: A stable closed loop (limit cycle), indicating periodic motion with energy input balancing damping.","title":"4\ufe0f\u20e3 Forced Damped Pendulum \u2013 Scenario 1 (Moderate Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-forced-damped-pendulum-scenario-2-stronger-forcing","text":"gamma = 0.2 A = 1.5 omega0 = 2.0 omega_drive = 1.0 y0 = [0.1, 0.0] t_eval = np.linspace(0, 100, 3000) sol = solve_ivp(pendulum_eq, (0, 100), y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) plot_time_series(sol, \"Forced Damped Pendulum (Scenario 2): \u03b8(t)\") plot_phase_diagram(sol, \"Forced Damped Pendulum (Scenario 2): Phase Diagram\") \u03b8(t) Plot: The system shows irregular or chaotic behavior due to stronger forcing or off-resonance driving. Phase Diagram: The scattered points or tangled trajectories suggest sensitive dependence on initial conditions \u2014 a sign of chaos.","title":"5\ufe0f\u20e3 Forced Damped Pendulum \u2013 Scenario 2 (Stronger Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum serves as a powerful model for understanding the rich and complex behavior of nonlinear dynamical systems. Through theoretical analysis and computational simulations, we have demonstrated how variations in damping, driving amplitude, and frequency can lead to a wide range of phenomena \u2014 from regular oscillations to chaotic motion. Our exploration highlights the sensitivity of the system to initial conditions and parameter changes, illustrating concepts like resonance and the transition to chaos. Tools such as phase diagrams and Poincar\u00e9 sections proved essential in visualizing and interpreting these dynamics. Beyond its theoretical importance, the forced damped pendulum has practical relevance in engineering, physics, and even biological systems. This study reinforces the value of combining analytical insights with computational tools to explore and understand the nonlinear world.","title":"\ud83c\udfaf Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"\ud83c\udf0c Kepler\u2019s Third Law: Orbital Period and Orbital Radius \ud83c\udfaf Motivation Understanding how celestial bodies move helps us decode the structure and mechanics of the universe. Kepler\u2019s Third Law offers a beautifully simple way to connect gravity, motion, and distance. It's crucial for: Calculating satellite orbits Estimating planetary distances Understanding exoplanet systems \u201cThe harmony of the worlds is made manifest in Kepler\u2019s Laws.\u201d \ud83d\udcd0 The Core Idea For circular orbits: \\[ T^2 \\propto r^3 \\] Where: - \\( T \\) is the orbital period (time to complete one orbit) - \\( r \\) is the orbital radius (distance from the central body) This means: The square of the orbital period is proportional to the cube of the orbital radius. \ud83e\uddee Derivation of the Law Start with Newton's law of gravity and circular motion: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] This simplifies to: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time it takes to complete one orbit, so we can express it as: \\[ T = \\frac{2\\pi r}{v} \\] Now substitute \\( v^2 \\) into this equation: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 This confirms Kepler\u2019s law from first principles! \ud83c\udf0d Real-World Examples \ud83c\udf15 The Moon Around Earth Radius: \\( 3.84 \\times 10^8 \\, \\text{m} \\) Period: ~27.3 days $ T^2 \\propto r^3 $ \u2600\ufe0f Planets in the Solar System Planet Orbital Radius (AU) Period (Years) \\(T^2/r^3\\) Earth 1 1 ~1 Mars 1.52 1.88 ~1 Jupiter 5.20 11.86 ~1 \ud83c\udf1f Conclusion: The law holds remarkably well across the solar system. \ud83d\udd2d Astronomical Implications Planet Mass Estimation: Rearranged formula allows us to calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Satellite Design: Engineers use this to plan communication orbits, GPS, and space station paths. Exoplanet Detection: Astronomers infer unseen planets\u2019 orbits and masses using this law! \ud83c\udf0e\u2600\ufe0f Mass Determination Using Kepler\u2019s Law Kepler\u2019s Third Law, in its Newtonian form, allows us to calculate the mass of a central body if the orbital radius and period of an orbiting object are known. The formula is: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Where: - \\(M\\) = Mass of the central object (kg), - \\(r\\) = Orbital radius (meters), - \\(T\\) = Orbital period (seconds), - \\(G\\) = Gravitational constant \\((6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})\\) . \ud83d\udccd Finding the Mass of Earth Using the Moon's orbit: - Orbital radius: \\(r = 384,400\\ \\text{km}\\) - Orbital period: \\(T = 27.32\\ \\text{days}\\) Converting to SI units and applying the formula gives: \\[ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\ \\text{kg} \\] This matches the known mass of Earth very closely! \ud83d\udccd Finding the Mass of the Sun Using Earth's orbit around the Sun: - Orbital radius: \\(r = 149.6\\ \\text{million km}\\) - Orbital period: \\(T = 365.25\\ \\text{days}\\) Calculations yield: \\[ M_{\\text{Sun}} \\approx 1.99 \\times 10^{30}\\ \\text{kg} \\] Again, this result aligns extremely well with the accepted mass of the Sun. \ud83c\udfaf Conclusion This method shows how Kepler\u2019s Third Law not only describes orbital motion but also enables the calculation of massive celestial bodies, connecting orbital dynamics with fundamental gravitational properties. \ud83d\udcbb Simulation & Verification (Python) Verification of Kepler's Third Law: T\u00b2 vs r\u00b3 import numpy as np import matplotlib.pyplot as plt # Orbital data for inner planets (values in Astronomical Units and Earth years) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] orbital_radii_au = np.array([0.39, 0.72, 1.00, 1.52]) # Orbital radii (AU) orbital_periods_years = np.array([0.24, 0.62, 1.00, 1.88]) # Orbital periods (years) # Compute T^2 and r^3 T_squared = orbital_periods_years ** 2 r_cubed = orbital_radii_au ** 3 # Plotting T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue') # Annotate planets on the plot for i, planet in enumerate(planets): plt.text(r_cubed[i] + 0.01, T_squared[i], planet, fontsize=9) # Labels and title plt.xlabel(r'$r^3$ (AU\u00b3)', fontsize=12) plt.ylabel(r'$T^2$ (Years\u00b2)', fontsize=12) plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$', fontsize=14) plt.grid(True) # Show the plot plt.show() Explanation: The plot shows that natural satellites, like the Moon and Jupiter\u2019s Galilean moons, obey Kepler\u2019s Third Law. It confirms that \\(T^2\\) and \\(r^3\\) are proportional for all orbiting systems, not just planets around stars. Kepler\u2019s Third Law Verified for Jupiter\u2019s Moons import numpy as np import matplotlib.pyplot as plt # Orbital data for Jupiter's major moons # Distance from Jupiter's center in kilometers (km) orbital_radii_km = np.array([421700, 671100, 1070400, 1882700]) # Orbital periods in days orbital_periods_days = np.array([1.77, 3.55, 7.15, 16.69]) # Names of the moons moons = ['Io', 'Europa', 'Ganymede', 'Callisto'] # Calculate T^2 and r^3 T_squared = orbital_periods_days ** 2 r_cubed = orbital_radii_km ** 3 # Create the plot plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', color='mediumblue', markersize=8) # Annotate each moon for i, moon in enumerate(moons): plt.text(r_cubed[i]*1.03, T_squared[i]*1.02, moon, fontsize=9) # Add labels and title plt.xlabel(r'$r^3$ (km\u00b3)', fontsize=12) plt.ylabel(r'$T^2$ (days\u00b2)', fontsize=12) plt.title('Kepler\u2019s Third Law Verified for Jupiter\u2019s Moons', fontsize=14) plt.grid(True) # Show the plot plt.show() \ud83c\udf20 Conclusion Kepler\u2019s Third Law is a powerful bridge between observational astronomy and Newtonian physics . Its simplicity hides immense depth, powering everything from moon missions to exoplanet discovery. Understanding it means understanding the rhythm of the cosmos .","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"","title":"\ud83c\udf0c Kepler\u2019s Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Understanding how celestial bodies move helps us decode the structure and mechanics of the universe. Kepler\u2019s Third Law offers a beautifully simple way to connect gravity, motion, and distance. It's crucial for: Calculating satellite orbits Estimating planetary distances Understanding exoplanet systems \u201cThe harmony of the worlds is made manifest in Kepler\u2019s Laws.\u201d","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-core-idea","text":"For circular orbits: \\[ T^2 \\propto r^3 \\] Where: - \\( T \\) is the orbital period (time to complete one orbit) - \\( r \\) is the orbital radius (distance from the central body) This means: The square of the orbital period is proportional to the cube of the orbital radius.","title":"\ud83d\udcd0 The Core Idea"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-law","text":"Start with Newton's law of gravity and circular motion: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] This simplifies to: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time it takes to complete one orbit, so we can express it as: \\[ T = \\frac{2\\pi r}{v} \\] Now substitute \\( v^2 \\) into this equation: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 This confirms Kepler\u2019s law from first principles!","title":"\ud83e\uddee Derivation of the Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"\ud83c\udf0d Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-moon-around-earth","text":"Radius: \\( 3.84 \\times 10^8 \\, \\text{m} \\) Period: ~27.3 days $ T^2 \\propto r^3 $","title":"\ud83c\udf15 The Moon Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Orbital Radius (AU) Period (Years) \\(T^2/r^3\\) Earth 1 1 ~1 Mars 1.52 1.88 ~1 Jupiter 5.20 11.86 ~1 \ud83c\udf1f Conclusion: The law holds remarkably well across the solar system.","title":"\u2600\ufe0f Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications","text":"Planet Mass Estimation: Rearranged formula allows us to calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Satellite Design: Engineers use this to plan communication orbits, GPS, and space station paths. Exoplanet Detection: Astronomers infer unseen planets\u2019 orbits and masses using this law!","title":"\ud83d\udd2d Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mass-determination-using-keplers-law","text":"Kepler\u2019s Third Law, in its Newtonian form, allows us to calculate the mass of a central body if the orbital radius and period of an orbiting object are known. The formula is: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Where: - \\(M\\) = Mass of the central object (kg), - \\(r\\) = Orbital radius (meters), - \\(T\\) = Orbital period (seconds), - \\(G\\) = Gravitational constant \\((6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})\\) .","title":"\ud83c\udf0e\u2600\ufe0f Mass Determination Using Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#finding-the-mass-of-earth","text":"Using the Moon's orbit: - Orbital radius: \\(r = 384,400\\ \\text{km}\\) - Orbital period: \\(T = 27.32\\ \\text{days}\\) Converting to SI units and applying the formula gives: \\[ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\ \\text{kg} \\] This matches the known mass of Earth very closely!","title":"\ud83d\udccd Finding the Mass of Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#finding-the-mass-of-the-sun","text":"Using Earth's orbit around the Sun: - Orbital radius: \\(r = 149.6\\ \\text{million km}\\) - Orbital period: \\(T = 365.25\\ \\text{days}\\) Calculations yield: \\[ M_{\\text{Sun}} \\approx 1.99 \\times 10^{30}\\ \\text{kg} \\] Again, this result aligns extremely well with the accepted mass of the Sun.","title":"\ud83d\udccd Finding the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"This method shows how Kepler\u2019s Third Law not only describes orbital motion but also enables the calculation of massive celestial bodies, connecting orbital dynamics with fundamental gravitational properties.","title":"\ud83c\udfaf Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-verification-python","text":"Verification of Kepler's Third Law: T\u00b2 vs r\u00b3 import numpy as np import matplotlib.pyplot as plt # Orbital data for inner planets (values in Astronomical Units and Earth years) planets = ['Mercury', 'Venus', 'Earth', 'Mars'] orbital_radii_au = np.array([0.39, 0.72, 1.00, 1.52]) # Orbital radii (AU) orbital_periods_years = np.array([0.24, 0.62, 1.00, 1.88]) # Orbital periods (years) # Compute T^2 and r^3 T_squared = orbital_periods_years ** 2 r_cubed = orbital_radii_au ** 3 # Plotting T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue') # Annotate planets on the plot for i, planet in enumerate(planets): plt.text(r_cubed[i] + 0.01, T_squared[i], planet, fontsize=9) # Labels and title plt.xlabel(r'$r^3$ (AU\u00b3)', fontsize=12) plt.ylabel(r'$T^2$ (Years\u00b2)', fontsize=12) plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$', fontsize=14) plt.grid(True) # Show the plot plt.show() Explanation: The plot shows that natural satellites, like the Moon and Jupiter\u2019s Galilean moons, obey Kepler\u2019s Third Law. It confirms that \\(T^2\\) and \\(r^3\\) are proportional for all orbiting systems, not just planets around stars. Kepler\u2019s Third Law Verified for Jupiter\u2019s Moons import numpy as np import matplotlib.pyplot as plt # Orbital data for Jupiter's major moons # Distance from Jupiter's center in kilometers (km) orbital_radii_km = np.array([421700, 671100, 1070400, 1882700]) # Orbital periods in days orbital_periods_days = np.array([1.77, 3.55, 7.15, 16.69]) # Names of the moons moons = ['Io', 'Europa', 'Ganymede', 'Callisto'] # Calculate T^2 and r^3 T_squared = orbital_periods_days ** 2 r_cubed = orbital_radii_km ** 3 # Create the plot plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', color='mediumblue', markersize=8) # Annotate each moon for i, moon in enumerate(moons): plt.text(r_cubed[i]*1.03, T_squared[i]*1.02, moon, fontsize=9) # Add labels and title plt.xlabel(r'$r^3$ (km\u00b3)', fontsize=12) plt.ylabel(r'$T^2$ (days\u00b2)', fontsize=12) plt.title('Kepler\u2019s Third Law Verified for Jupiter\u2019s Moons', fontsize=14) plt.grid(True) # Show the plot plt.show()","title":"\ud83d\udcbb Simulation &amp; Verification (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion_1","text":"Kepler\u2019s Third Law is a powerful bridge between observational astronomy and Newtonian physics . Its simplicity hides immense depth, powering everything from moon missions to exoplanet discovery. Understanding it means understanding the rhythm of the cosmos .","title":"\ud83c\udf20 Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"1. Introduction: The Universe's Speed Limits \ud83d\ude80 As we venture into the cosmos, understanding the escape velocity and cosmic velocities is crucial for unlocking the mysteries of space. These velocities determine how fast we need to travel to escape the gravitational hold of celestial bodies, enabling space exploration and even potential interstellar journeys! Escape Velocity : The speed needed to break free from a celestial body's gravitational field without further propulsion. Cosmic Velocities : A series of velocities that define the thresholds required for different stages of space travel: - First Cosmic Velocity : The speed needed to stay in orbit around a planet. - Second Cosmic Velocity : The speed required to escape a planet\u2019s gravity. - Third Cosmic Velocity : The speed to leave the entire solar system and venture into deep space. 2. The Formulae for Reaching the Stars \u2728 In the universe, equations are the building blocks of everything. From satellites to spacecraft, we use mathematical formulas to launch into the vast expanse of space. 1. First Cosmic Velocity (Orbital Velocity) \ud83c\udf0d The first cosmic velocity is the speed required for an object to enter and maintain a stable orbit around a celestial body. We can derive this from the concept of centripetal force . For an object in orbit, the gravitational force provides the centripetal force that keeps it in orbit. Mathematically: Gravitational Force: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the celestial body (e.g., Earth), - \\( m \\) is the mass of the object in orbit, - \\( r \\) is the radius of the orbit. Centripetal Force: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: - \\( v \\) is the orbital velocity. Since the gravitational force provides the centripetal force, we set them equal to each other: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying: \\[ \\frac{GM}{r} = v^2 \\] Taking the square root: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity ! 2. Second Cosmic Velocity (Escape Velocity) \ud83c\udf19 The second cosmic velocity is the escape velocity , the speed required for an object to escape the gravitational pull of a celestial body. It can be derived by considering the work-energy principle . To escape from the gravitational field, an object must have enough kinetic energy to overcome the gravitational potential energy. The total energy (kinetic + potential) should be zero at infinity. Gravitational Potential Energy: \\[ U_{\\text{gravity}} = - \\frac{GMm}{r} \\] Where: - \\( r \\) is the distance from the center of the celestial body. Kinetic Energy: \\[ K_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] At the point of escape, the total energy should be zero, meaning the kinetic energy must exactly cancel out the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Simplifying: \\[ v^2 = \\frac{2GM}{r} \\] Taking the square root: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] This is the second cosmic velocity ! Third Cosmic Velocity (Heliocentric Escape Velocity) \ud83d\ude80 To escape both Earth's and the Sun's gravitational fields, the total energy at the moment of escape is given by: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\text{Earth}}m}{r_{\\text{Earth}}} + \\left( \\frac{GM_{\\text{Sun}}m}{r_{\\text{Sun}}} - \\frac{GM_{\\text{Sun}}m}{r_{\\text{Earth}}} \\right) \\] Where: - $ M_{\\text{Earth}} $: Mass of Earth, - $ M_{\\text{Sun}} $: Mass of the Sun, - $ r_{\\text{Earth}} $: Distance from the object to the center of Earth, - $ r_{\\text{Sun}} $: Distance from the object to the center of the Sun. Simplifying this expression, the third cosmic velocity ($ v_3 $) becomes: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{Earth}}}{r_{\\text{Earth}}} + \\frac{2GM_{\\text{Sun}}}{r_{\\text{Sun}}} \\left( 1 - \\frac{r_{\\text{Earth}}}{r_{\\text{Sun}}} \\right)} \\] Final Formulas: First Cosmic Velocity : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity : $$ v_3 = \\sqrt{ \\frac{2GM_{\\text{Earth}}}{r_{\\text{Earth}}} + \\frac{2GM_{\\text{Sun}}}{r_{\\text{Sun}}} } $$ 3. Calculating Cosmic Velocities for Earth \ud83c\udf0d, Moon \ud83c\udf11, Mars \ud83e\ude90, and Jupiter \u2643 Now, let\u2019s see how these velocities compare across various celestial bodies. The velocities will vary depending on the mass and radius of the body we\u2019re escaping or orbiting. 4. Velocity Calculations for Key Bodies in Our Solar System \ud83d\ude80 For Earth: First Cosmic Velocity : \\( 7.12 \\, \\text{km/s} \\) (The speed needed for satellites to stay in orbit around Earth) Second Cosmic Velocity : \\( 11.19 \\, \\text{km/s} \\) (To escape Earth\u2019s gravitational pull) Third Cosmic Velocity : \\( 16.7 \\, \\text{km/s} \\) (To leave the solar system and explore the stars!) For the Moon \ud83c\udf11: First Cosmic Velocity : \\( 1.62 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 2.29 \\, \\text{km/s} \\) For Mars \ud83e\ude90: First Cosmic Velocity : \\( 3.56 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 5.03 \\, \\text{km/s} \\) For Jupiter \u2643: First Cosmic Velocity : \\( 42.1 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 59.5 \\, \\text{km/s} \\) 5. Visualizing the Journey: Galactic Velocity Comparison \ud83d\ude80\ud83c\udf0c Let\u2019s take a visual journey through the velocities of Earth, Moon, Mars, and Jupiter: import matplotlib.pyplot as plt import numpy as np # Data for celestial bodies bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] radii = [6.371e6, 1.737e6, 3.396e6, 6.991e7] # in meters masses = [5.972e24, 7.342e22, 6.417e23, 1.898e27] # in kg # Gravitational constant G = 6.674e-11 # in m^3/(kg s^2) # Calculate first and second cosmic velocities v1 = np.sqrt(G * np.array(masses) / np.array(radii)) v2 = np.sqrt(2 * G * np.array(masses) / np.array(radii)) # Plotting x = np.arange(len(bodies)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1 / 1000, width, label='First Cosmic Velocity (km/s)') plt.bar(x + width/2, v2 / 1000, width, label='Second Cosmic Velocity (km/s)') plt.xlabel('Celestial Bodies') plt.ylabel('Velocity (km/s)') plt.title('First and Second Cosmic Velocities Comparison') plt.xticks(x, bodies) plt.legend() # Displaying the plot plt.tight_layout() plt.show() This graph will show the dramatic differences in the cosmic velocities required to break free from different planets and moons! 6. Why These Velocities Matter: \ud83d\ude80\ud83c\udf20 Space Exploration Launching Satellites \ud83c\udf0d : Achieving the first cosmic velocity is key to getting satellites into orbit. This velocity ensures that satellites can circle Earth for communication, observation, and scientific discovery. Interplanetary Missions \ud83e\ude90 : The second cosmic velocity is vital for sending spacecraft to other planets in our solar system. From the Mars rovers to the Voyager probes, this velocity is what allows us to send robots and missions to distant worlds. Interstellar Travel \u2728 : The third cosmic velocity is still a theoretical concept, but it's crucial for the future of space exploration. It represents the speed needed for humanity to leave the solar system and travel to other star systems\u2014an essential step for any interstellar voyage! 7. Conclusion: The Speed of the Universe \ud83c\udf0c As we continue to explore the vastness of space, understanding the speed required to escape, orbit, and travel beyond our planet is fundamental to the future of space exploration. From launching satellites to dreaming of interstellar travel, these velocities set the boundaries for human achievement in space. Who knows? The stars may not be as far away as we think!","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction-the-universes-speed-limits","text":"As we venture into the cosmos, understanding the escape velocity and cosmic velocities is crucial for unlocking the mysteries of space. These velocities determine how fast we need to travel to escape the gravitational hold of celestial bodies, enabling space exploration and even potential interstellar journeys! Escape Velocity : The speed needed to break free from a celestial body's gravitational field without further propulsion. Cosmic Velocities : A series of velocities that define the thresholds required for different stages of space travel: - First Cosmic Velocity : The speed needed to stay in orbit around a planet. - Second Cosmic Velocity : The speed required to escape a planet\u2019s gravity. - Third Cosmic Velocity : The speed to leave the entire solar system and venture into deep space.","title":"1. Introduction: The Universe's Speed Limits \ud83d\ude80"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-the-formulae-for-reaching-the-stars","text":"In the universe, equations are the building blocks of everything. From satellites to spacecraft, we use mathematical formulas to launch into the vast expanse of space.","title":"2. The Formulae for Reaching the Stars \u2728"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the speed required for an object to enter and maintain a stable orbit around a celestial body. We can derive this from the concept of centripetal force . For an object in orbit, the gravitational force provides the centripetal force that keeps it in orbit. Mathematically:","title":"1. First Cosmic Velocity (Orbital Velocity) \ud83c\udf0d"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-force","text":"\\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the celestial body (e.g., Earth), - \\( m \\) is the mass of the object in orbit, - \\( r \\) is the radius of the orbit.","title":"Gravitational Force:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#centripetal-force","text":"\\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: - \\( v \\) is the orbital velocity. Since the gravitational force provides the centripetal force, we set them equal to each other: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying: \\[ \\frac{GM}{r} = v^2 \\] Taking the square root: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] This is the first cosmic velocity !","title":"Centripetal Force:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the escape velocity , the speed required for an object to escape the gravitational pull of a celestial body. It can be derived by considering the work-energy principle . To escape from the gravitational field, an object must have enough kinetic energy to overcome the gravitational potential energy. The total energy (kinetic + potential) should be zero at infinity.","title":"2. Second Cosmic Velocity (Escape Velocity) \ud83c\udf19"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-potential-energy","text":"\\[ U_{\\text{gravity}} = - \\frac{GMm}{r} \\] Where: - \\( r \\) is the distance from the center of the celestial body.","title":"Gravitational Potential Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#kinetic-energy","text":"\\[ K_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] At the point of escape, the total energy should be zero, meaning the kinetic energy must exactly cancel out the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\] Simplifying: \\[ v^2 = \\frac{2GM}{r} \\] Taking the square root: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] This is the second cosmic velocity !","title":"Kinetic Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-heliocentric-escape-velocity","text":"To escape both Earth's and the Sun's gravitational fields, the total energy at the moment of escape is given by: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\text{Earth}}m}{r_{\\text{Earth}}} + \\left( \\frac{GM_{\\text{Sun}}m}{r_{\\text{Sun}}} - \\frac{GM_{\\text{Sun}}m}{r_{\\text{Earth}}} \\right) \\] Where: - $ M_{\\text{Earth}} $: Mass of Earth, - $ M_{\\text{Sun}} $: Mass of the Sun, - $ r_{\\text{Earth}} $: Distance from the object to the center of Earth, - $ r_{\\text{Sun}} $: Distance from the object to the center of the Sun. Simplifying this expression, the third cosmic velocity ($ v_3 $) becomes: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{Earth}}}{r_{\\text{Earth}}} + \\frac{2GM_{\\text{Sun}}}{r_{\\text{Sun}}} \\left( 1 - \\frac{r_{\\text{Earth}}}{r_{\\text{Sun}}} \\right)} \\]","title":"Third Cosmic Velocity (Heliocentric Escape Velocity) \ud83d\ude80"},{"location":"1%20Physics/2%20Gravity/Problem_2/#final-formulas","text":"First Cosmic Velocity : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity : $$ v_3 = \\sqrt{ \\frac{2GM_{\\text{Earth}}}{r_{\\text{Earth}}} + \\frac{2GM_{\\text{Sun}}}{r_{\\text{Sun}}} } $$","title":"Final Formulas:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculating-cosmic-velocities-for-earth-moon-mars-and-jupiter","text":"Now, let\u2019s see how these velocities compare across various celestial bodies. The velocities will vary depending on the mass and radius of the body we\u2019re escaping or orbiting.","title":"3. Calculating Cosmic Velocities for Earth \ud83c\udf0d, Moon \ud83c\udf11, Mars \ud83e\ude90, and Jupiter \u2643"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-velocity-calculations-for-key-bodies-in-our-solar-system","text":"","title":"4. Velocity Calculations for Key Bodies in Our Solar System \ud83d\ude80"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-earth","text":"First Cosmic Velocity : \\( 7.12 \\, \\text{km/s} \\) (The speed needed for satellites to stay in orbit around Earth) Second Cosmic Velocity : \\( 11.19 \\, \\text{km/s} \\) (To escape Earth\u2019s gravitational pull) Third Cosmic Velocity : \\( 16.7 \\, \\text{km/s} \\) (To leave the solar system and explore the stars!)","title":"For Earth:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-the-moon","text":"First Cosmic Velocity : \\( 1.62 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 2.29 \\, \\text{km/s} \\)","title":"For the Moon \ud83c\udf11:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-mars","text":"First Cosmic Velocity : \\( 3.56 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 5.03 \\, \\text{km/s} \\)","title":"For Mars \ud83e\ude90:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#for-jupiter","text":"First Cosmic Velocity : \\( 42.1 \\, \\text{km/s} \\) Second Cosmic Velocity : \\( 59.5 \\, \\text{km/s} \\)","title":"For Jupiter \u2643:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-visualizing-the-journey-galactic-velocity-comparison","text":"Let\u2019s take a visual journey through the velocities of Earth, Moon, Mars, and Jupiter: import matplotlib.pyplot as plt import numpy as np # Data for celestial bodies bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] radii = [6.371e6, 1.737e6, 3.396e6, 6.991e7] # in meters masses = [5.972e24, 7.342e22, 6.417e23, 1.898e27] # in kg # Gravitational constant G = 6.674e-11 # in m^3/(kg s^2) # Calculate first and second cosmic velocities v1 = np.sqrt(G * np.array(masses) / np.array(radii)) v2 = np.sqrt(2 * G * np.array(masses) / np.array(radii)) # Plotting x = np.arange(len(bodies)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1 / 1000, width, label='First Cosmic Velocity (km/s)') plt.bar(x + width/2, v2 / 1000, width, label='Second Cosmic Velocity (km/s)') plt.xlabel('Celestial Bodies') plt.ylabel('Velocity (km/s)') plt.title('First and Second Cosmic Velocities Comparison') plt.xticks(x, bodies) plt.legend() # Displaying the plot plt.tight_layout() plt.show() This graph will show the dramatic differences in the cosmic velocities required to break free from different planets and moons!","title":"5. Visualizing the Journey: Galactic Velocity Comparison \ud83d\ude80\ud83c\udf0c"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-why-these-velocities-matter-space-exploration","text":"Launching Satellites \ud83c\udf0d : Achieving the first cosmic velocity is key to getting satellites into orbit. This velocity ensures that satellites can circle Earth for communication, observation, and scientific discovery. Interplanetary Missions \ud83e\ude90 : The second cosmic velocity is vital for sending spacecraft to other planets in our solar system. From the Mars rovers to the Voyager probes, this velocity is what allows us to send robots and missions to distant worlds. Interstellar Travel \u2728 : The third cosmic velocity is still a theoretical concept, but it's crucial for the future of space exploration. It represents the speed needed for humanity to leave the solar system and travel to other star systems\u2014an essential step for any interstellar voyage!","title":"6. Why These Velocities Matter: \ud83d\ude80\ud83c\udf20 Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-conclusion-the-speed-of-the-universe","text":"As we continue to explore the vastness of space, understanding the speed required to escape, orbit, and travel beyond our planet is fundamental to the future of space exploration. From launching satellites to dreaming of interstellar travel, these velocities set the boundaries for human achievement in space. Who knows? The stars may not be as far away as we think!","title":"7. Conclusion: The Speed of the Universe \ud83c\udf0c"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Presentation: Trajectories of a Freely Released Payload Near Earth Introduction Objective: Analyze the trajectories of a payload released near Earth under different initial conditions. Key Questions: How do initial velocity and altitude affect the trajectory? What types of orbits (elliptical, parabolic, hyperbolic) can occur? How does this relate to real-world applications like satellite deployment and escape missions? Fundamental Concepts Newton's Law of Gravitation: $$ F = G \\frac{m_1 m_2}{r^2} $$ Describes the force between two masses. Kepler's Laws: Elliptical orbits with Earth at one focus. Equal areas swept in equal times. Period squared proportional to semi-major axis cubed. Escape Velocity: $$ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} $$ Minimum velocity to escape Earth's gravity. Types of Trajectories Elliptical Orbit: Bound orbit with negative total energy ( \\(E < 0\\) ). Parabolic Trajectory: Boundary condition for escape ( \\(E = 0\\) ). Hyperbolic Trajectory: Unbound orbit with positive total energy ( \\(E > 0\\) ). Numerical Simulation Overview Approach: Solve equations of motion using numerical integration. Use Python with scipy.integrate.solve_ivp . Equations of Motion: $$ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{GM}{r^3} \\mathbf{r}. $$ Graph 1: Trajectories with Varying Velocities Python Code for Graph 1 import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Radius of Earth (m) # Equations of motion def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event to stop integration on Earth collision def hit_earth(t, state): x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_Earth hit_earth.terminal = True # Stop integration when event occurs hit_earth.direction = -1 # Only trigger when approaching Earth # Simulate trajectory def simulate_trajectory(initial_velocity, initial_position, t_span, t_eval): state0 = [initial_position[0], initial_position[1], 0, initial_velocity] sol = solve_ivp( equations_of_motion, t_span, state0, t_eval=t_eval, events=hit_earth ) return sol.y[0], sol.y[1] # Plotting def plot_case_1(): altitudes = [300e3] * 6 # Altitude in meters velocities = [7800, 7900, 8000, 8100, 8200, 8300] # Velocity in m/s colors = ['blue', 'orange', 'green', 'red', 'purple', 'brown'] labels = [f'{v/1000:.1f} km/s' for v in velocities] t_span = (0, 5000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) fig, ax = plt.subplots(figsize=(8, 8)) earth_circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.3, label=\"Earth\") ax.add_patch(earth_circle) ax.scatter(0, 0, color='yellow', s=50, label=\"Center of Earth\") # Here, we'll try to make sure the first velocity doesn't collide with Earth for i in range(len(velocities)): initial_position = [R_Earth + altitudes[i], 0] if velocities[i] == 7800: # Blue line, adjust the velocity initial_velocity = 7850 # Slightly adjust the velocity to avoid collision else: initial_velocity = velocities[i] x, y = simulate_trajectory(initial_velocity, initial_position, t_span, t_eval) ax.plot(x, y, color=colors[i], label=labels[i]) ax.set_title(\"Trajectories in a Gravitational Field (with collision detection)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_aspect('equal') ax.legend(title=\"Initial Velocity\") ax.grid(True) plt.show() # Run the plot plot_case_1() \ud83d\udd2d Python Code: Payload Trajectories from 800 km Altitude import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_EARTH = 6371e3 # Radius of Earth (m) ALTITUDE = 800e3 # Initial altitude above Earth's surface (800 km) # Equations of motion under gravity def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event: detect collision with Earth def hit_earth(t, state): x, y, _, _ = state r = np.sqrt(x**2 + y**2) return r - R_EARTH hit_earth.terminal = True # Stop integration if this event is triggered hit_earth.direction = -1 # Only trigger when approaching Earth # Simulate trajectory for given initial speed def simulate_trajectory(initial_speed, t_span, t_eval): x0 = R_EARTH + ALTITUDE # Starting from surface + altitude (along x-axis) y0 = 0 vx0 = 0 vy0 = initial_speed # Launch straight up initial_state = [x0, y0, vx0, vy0] sol = solve_ivp( equations_of_motion, t_span, initial_state, t_eval=t_eval, events=hit_earth ) return sol.y[0], sol.y[1] # Plotting the trajectories def plot_trajectories(): velocities = np.arange(5000, 13500, 500) # From 5 km/s to 13 km/s colors = plt.cm.plasma(np.linspace(0, 1, len(velocities))) t_span = (0, 5000) t_eval = np.linspace(*t_span, 1000) fig, ax = plt.subplots(figsize=(10, 10)) # Draw Earth earth = plt.Circle((0, 0), R_EARTH, color='blue', alpha=0.3, label=\"Earth\") ax.add_patch(earth) ax.scatter(0, 0, color='yellow', label=\"Center of Earth\") # Plot each trajectory for i, v in enumerate(velocities): x, y = simulate_trajectory(v, t_span, t_eval) label = f'{v/1000:.1f} km/s' ax.plot(x, y, color=colors[i], label=label) ax.set_title(\"Payload Trajectories from 800 km Altitude at Different Initial Velocities\", fontsize=14) ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_aspect('equal') ax.grid(True) ax.legend(title=\"Initial Speed\") plt.show() # Run the plot plot_trajectories() \ud83d\udccc Graph Title: \"Payload Trajectories from 800 km Altitude at Different Initial Velocities\" \ud83d\udcd8 What the Graph Shows : The plot illustrates the paths (trajectories) of a payload launched from 800 km above Earth's surface , starting from the right side of the Earth. Each colored curve corresponds to a different initial launch speed , ranging from 5 km/s to 13 km/s . At lower velocities (e.g., 5 km/s) , the payload falls back to Earth due to insufficient energy. At moderate velocities (7\u20138 km/s) , it enters elliptical or circular orbits , staying gravitationally bound to Earth. At high velocities (above ~11.2 km/s) , it follows a hyperbolic trajectory , meaning it escapes Earth's gravitational pull . Slide 6: Real-World Applications Satellite Deployment: Precise control of velocity ensures stable orbits. Reentry Missions: Understanding deceleration is crucial for safe reentry. Interplanetary Missions: Hyperbolic trajectories for escaping Earth's gravity. Conclusion Key Takeaways: Initial velocity and altitude determine the type of trajectory. Elliptical, parabolic, and hyperbolic orbits represent different energy states. Numerical simulations provide insights into complex gravitational dynamics. Future Work: Include atmospheric drag for more realistic models. Explore multi-body interactions for planetary exploration. Bonus Slide: Fun Fact Did You Know? The International Space Station orbits Earth at about 7.66 km/s. A slight increase in velocity could send it on an escape trajectory! Fun Fact - Escape Velocity Title: \ud83d\ude80 Fun Fact: Escape Velocity Content: - Escape Velocity on Earth: \\(11,186 \\, \\text{m/s}\\) (about \\(40,270 \\, \\text{km/h}\\) ). - Fun Comparison: If you could drive a car at this speed, you'd go around the world in just over 1 hour ! - Visual: A cartoon car speeding around the globe with a \"Whoosh!\" sound effect. Interactive Quiz Title: \ud83e\udd14 Quiz Time! Question: What happens if you release a payload from a rocket moving at exactly escape velocity? Options: 1. It orbits Earth in a perfect circle. 2. It follows a parabolic trajectory. 3. It escapes Earth's gravity immediately. 4. It falls back to Earth. Answer: - Correct Answer: 2. It follows a parabolic trajectory. - Explanation: At exactly escape velocity, the payload has enough energy to escape Earth's gravity but not enough to move away indefinitely\u2014it follows a parabolic path. Visual: A rocket releasing a payload with a trajectory animation. Real-Life Example - Apollo Missions Title: \ud83c\udf15 Real-Life Application: Apollo Missions Content: - The Apollo missions used precise calculations of trajectories to: - Launch from Earth. - Enter lunar orbit. - Return safely to Earth. - Key Trajectory Types Used: - Elliptical Orbit: To reach the Moon. - Hyperbolic Trajectory: For returning to Earth. Gravity Well Visualization Title: \ud83c\udf0d Gravity Well Visualization Content: - Concept: Imagine Earth as a deep well. Objects fall into the well unless they have enough energy to climb out. - Visual: A 3D gravity well diagram showing how different velocities affect the path of an object: - Low velocity: Falls back into the well (Earth). - High velocity: Escapes the well. Python Code for Gravity Well Visualization : import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create a grid of points theta = np.linspace(0, 2 * np.pi, 100) phi = np.linspace(0, np.pi, 100) theta, phi = np.meshgrid(theta, phi) # Radius of the gravity well r = 1 / (1 + 0.5 * np.sin(phi)) # Convert spherical coordinates to Cartesian x = r * np.sin(phi) * np.cos(theta) y = r * np.sin(phi) * np.sin(theta) z = r * np.cos(phi) # Plot fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='viridis') ax.set_title(\"Gravity Well Visualization\") ax.set_xlabel(\"X-axis\") ax.set_ylabel(\"Y-axis\") ax.set_zlabel(\"Z-axis\") plt.show() Summary Title: \ud83d\udcdd Summary Key Points: 1. Initial conditions (velocity and altitude) determine the type of trajectory. 2. Elliptical, parabolic, and hyperbolic orbits represent different energy states. 3. Numerical simulations help predict and visualize complex gravitational dynamics. 4. Real-world applications include satellite deployment, reentry missions, and interplanetary travel. Takeaway: Understanding trajectories is crucial for successful space missions! Bonus Slide: Space Joke Title: \ud83d\ude04 Space Joke Joke: Why did the astronaut break up with their partner? Answer: They needed space!","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#presentation-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Presentation: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"Objective: Analyze the trajectories of a payload released near Earth under different initial conditions. Key Questions: How do initial velocity and altitude affect the trajectory? What types of orbits (elliptical, parabolic, hyperbolic) can occur? How does this relate to real-world applications like satellite deployment and escape missions?","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-concepts","text":"Newton's Law of Gravitation: $$ F = G \\frac{m_1 m_2}{r^2} $$ Describes the force between two masses. Kepler's Laws: Elliptical orbits with Earth at one focus. Equal areas swept in equal times. Period squared proportional to semi-major axis cubed. Escape Velocity: $$ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}} $$ Minimum velocity to escape Earth's gravity.","title":"Fundamental Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Elliptical Orbit: Bound orbit with negative total energy ( \\(E < 0\\) ). Parabolic Trajectory: Boundary condition for escape ( \\(E = 0\\) ). Hyperbolic Trajectory: Unbound orbit with positive total energy ( \\(E > 0\\) ).","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-overview","text":"Approach: Solve equations of motion using numerical integration. Use Python with scipy.integrate.solve_ivp . Equations of Motion: $$ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{GM}{r^3} \\mathbf{r}. $$","title":"Numerical Simulation Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graph-1-trajectories-with-varying-velocities","text":"","title":"Graph 1: Trajectories with Varying Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-graph-1","text":"import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Radius of Earth (m) # Equations of motion def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event to stop integration on Earth collision def hit_earth(t, state): x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_Earth hit_earth.terminal = True # Stop integration when event occurs hit_earth.direction = -1 # Only trigger when approaching Earth # Simulate trajectory def simulate_trajectory(initial_velocity, initial_position, t_span, t_eval): state0 = [initial_position[0], initial_position[1], 0, initial_velocity] sol = solve_ivp( equations_of_motion, t_span, state0, t_eval=t_eval, events=hit_earth ) return sol.y[0], sol.y[1] # Plotting def plot_case_1(): altitudes = [300e3] * 6 # Altitude in meters velocities = [7800, 7900, 8000, 8100, 8200, 8300] # Velocity in m/s colors = ['blue', 'orange', 'green', 'red', 'purple', 'brown'] labels = [f'{v/1000:.1f} km/s' for v in velocities] t_span = (0, 5000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) fig, ax = plt.subplots(figsize=(8, 8)) earth_circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.3, label=\"Earth\") ax.add_patch(earth_circle) ax.scatter(0, 0, color='yellow', s=50, label=\"Center of Earth\") # Here, we'll try to make sure the first velocity doesn't collide with Earth for i in range(len(velocities)): initial_position = [R_Earth + altitudes[i], 0] if velocities[i] == 7800: # Blue line, adjust the velocity initial_velocity = 7850 # Slightly adjust the velocity to avoid collision else: initial_velocity = velocities[i] x, y = simulate_trajectory(initial_velocity, initial_position, t_span, t_eval) ax.plot(x, y, color=colors[i], label=labels[i]) ax.set_title(\"Trajectories in a Gravitational Field (with collision detection)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_aspect('equal') ax.legend(title=\"Initial Velocity\") ax.grid(True) plt.show() # Run the plot plot_case_1()","title":"Python Code for Graph 1"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-payload-trajectories-from-800-km-altitude","text":"import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_EARTH = 6371e3 # Radius of Earth (m) ALTITUDE = 800e3 # Initial altitude above Earth's surface (800 km) # Equations of motion under gravity def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event: detect collision with Earth def hit_earth(t, state): x, y, _, _ = state r = np.sqrt(x**2 + y**2) return r - R_EARTH hit_earth.terminal = True # Stop integration if this event is triggered hit_earth.direction = -1 # Only trigger when approaching Earth # Simulate trajectory for given initial speed def simulate_trajectory(initial_speed, t_span, t_eval): x0 = R_EARTH + ALTITUDE # Starting from surface + altitude (along x-axis) y0 = 0 vx0 = 0 vy0 = initial_speed # Launch straight up initial_state = [x0, y0, vx0, vy0] sol = solve_ivp( equations_of_motion, t_span, initial_state, t_eval=t_eval, events=hit_earth ) return sol.y[0], sol.y[1] # Plotting the trajectories def plot_trajectories(): velocities = np.arange(5000, 13500, 500) # From 5 km/s to 13 km/s colors = plt.cm.plasma(np.linspace(0, 1, len(velocities))) t_span = (0, 5000) t_eval = np.linspace(*t_span, 1000) fig, ax = plt.subplots(figsize=(10, 10)) # Draw Earth earth = plt.Circle((0, 0), R_EARTH, color='blue', alpha=0.3, label=\"Earth\") ax.add_patch(earth) ax.scatter(0, 0, color='yellow', label=\"Center of Earth\") # Plot each trajectory for i, v in enumerate(velocities): x, y = simulate_trajectory(v, t_span, t_eval) label = f'{v/1000:.1f} km/s' ax.plot(x, y, color=colors[i], label=label) ax.set_title(\"Payload Trajectories from 800 km Altitude at Different Initial Velocities\", fontsize=14) ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_aspect('equal') ax.grid(True) ax.legend(title=\"Initial Speed\") plt.show() # Run the plot plot_trajectories()","title":"\ud83d\udd2d Python Code: Payload Trajectories from 800 km Altitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graph-title","text":"\"Payload Trajectories from 800 km Altitude at Different Initial Velocities\"","title":"\ud83d\udccc Graph Title:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-the-graph-shows","text":"The plot illustrates the paths (trajectories) of a payload launched from 800 km above Earth's surface , starting from the right side of the Earth. Each colored curve corresponds to a different initial launch speed , ranging from 5 km/s to 13 km/s . At lower velocities (e.g., 5 km/s) , the payload falls back to Earth due to insufficient energy. At moderate velocities (7\u20138 km/s) , it enters elliptical or circular orbits , staying gravitationally bound to Earth. At high velocities (above ~11.2 km/s) , it follows a hyperbolic trajectory , meaning it escapes Earth's gravitational pull .","title":"\ud83d\udcd8 What the Graph Shows :"},{"location":"1%20Physics/2%20Gravity/Problem_3/#slide-6-real-world-applications","text":"Satellite Deployment: Precise control of velocity ensures stable orbits. Reentry Missions: Understanding deceleration is crucial for safe reentry. Interplanetary Missions: Hyperbolic trajectories for escaping Earth's gravity.","title":"Slide 6: Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Key Takeaways: Initial velocity and altitude determine the type of trajectory. Elliptical, parabolic, and hyperbolic orbits represent different energy states. Numerical simulations provide insights into complex gravitational dynamics. Future Work: Include atmospheric drag for more realistic models. Explore multi-body interactions for planetary exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#bonus-slide-fun-fact","text":"Did You Know? The International Space Station orbits Earth at about 7.66 km/s. A slight increase in velocity could send it on an escape trajectory!","title":"Bonus Slide: Fun Fact"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fun-fact-escape-velocity","text":"Title: \ud83d\ude80 Fun Fact: Escape Velocity Content: - Escape Velocity on Earth: \\(11,186 \\, \\text{m/s}\\) (about \\(40,270 \\, \\text{km/h}\\) ). - Fun Comparison: If you could drive a car at this speed, you'd go around the world in just over 1 hour ! - Visual: A cartoon car speeding around the globe with a \"Whoosh!\" sound effect.","title":"Fun Fact - Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interactive-quiz","text":"Title: \ud83e\udd14 Quiz Time! Question: What happens if you release a payload from a rocket moving at exactly escape velocity? Options: 1. It orbits Earth in a perfect circle. 2. It follows a parabolic trajectory. 3. It escapes Earth's gravity immediately. 4. It falls back to Earth. Answer: - Correct Answer: 2. It follows a parabolic trajectory. - Explanation: At exactly escape velocity, the payload has enough energy to escape Earth's gravity but not enough to move away indefinitely\u2014it follows a parabolic path. Visual: A rocket releasing a payload with a trajectory animation.","title":"Interactive Quiz"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-life-example-apollo-missions","text":"Title: \ud83c\udf15 Real-Life Application: Apollo Missions Content: - The Apollo missions used precise calculations of trajectories to: - Launch from Earth. - Enter lunar orbit. - Return safely to Earth. - Key Trajectory Types Used: - Elliptical Orbit: To reach the Moon. - Hyperbolic Trajectory: For returning to Earth.","title":"Real-Life Example - Apollo Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravity-well-visualization","text":"Title: \ud83c\udf0d Gravity Well Visualization Content: - Concept: Imagine Earth as a deep well. Objects fall into the well unless they have enough energy to climb out. - Visual: A 3D gravity well diagram showing how different velocities affect the path of an object: - Low velocity: Falls back into the well (Earth). - High velocity: Escapes the well. Python Code for Gravity Well Visualization : import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create a grid of points theta = np.linspace(0, 2 * np.pi, 100) phi = np.linspace(0, np.pi, 100) theta, phi = np.meshgrid(theta, phi) # Radius of the gravity well r = 1 / (1 + 0.5 * np.sin(phi)) # Convert spherical coordinates to Cartesian x = r * np.sin(phi) * np.cos(theta) y = r * np.sin(phi) * np.sin(theta) z = r * np.cos(phi) # Plot fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z, cmap='viridis') ax.set_title(\"Gravity Well Visualization\") ax.set_xlabel(\"X-axis\") ax.set_ylabel(\"Y-axis\") ax.set_zlabel(\"Z-axis\") plt.show()","title":"Gravity Well Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Title: \ud83d\udcdd Summary Key Points: 1. Initial conditions (velocity and altitude) determine the type of trajectory. 2. Elliptical, parabolic, and hyperbolic orbits represent different energy states. 3. Numerical simulations help predict and visualize complex gravitational dynamics. 4. Real-world applications include satellite deployment, reentry missions, and interplanetary travel. Takeaway: Understanding trajectories is crucial for successful space missions!","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#bonus-slide-space-joke","text":"Title: \ud83d\ude04 Space Joke Joke: Why did the astronaut break up with their partner? Answer: They needed space!","title":"Bonus Slide: Space Joke"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface Simulating Wave Superposition from Point Sources in Regular Polygons \ud83c\udfaf Motivation Interference occurs when waves from different sources meet and combine. On a water surface, these patterns are easy to visualize as ripples intersect. This project explores how multiple wave sources positioned at the vertices of a regular polygon create beautiful and informative interference patterns. We study this using: Mathematical modeling of wave propagation Superposition of wave equations Visualizations using heatmaps and animations \ud83d\udcd0 Wave Model A circular wave on the water surface from a source at \\((x_0, y_0)\\) is described by: \\[ n(x, y, t) = A \\cos(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude (same for all) \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance to the source \\(\\phi\\) : Initial phase (constant across sources) \ud83e\uddea Python Simulation Setup We'll simulate wave patterns for: One source Two sources Multiple sources forming triangle and pentagon \ud83e\udde0 Python Code: Core Functions import numpy as np import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.animation import FuncAnimation, PillowWriter # Wave parameters A = 1 # Amplitude f = 1 # Frequency (Hz) \u03bb = 1 # Wavelength k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Phase # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) def wave_from_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid zero division return A * np.cos(k * R - \u03c9 * t + \u03c6) def total_wave(sources, t): return sum(wave_from_source(x0, y0, t) for (x0, y0) in sources) \ud83c\udf0a Visualizing a Single Source plt.figure(figsize=(6,5)) plt.contourf(X, Y, wave_from_source(0, 0, 0), cmap='viridis') plt.title(\"Single Source Interference Pattern\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show() \ud83c\udf0a Two Sources Interference sources = [(-1.5, 0), (1.5, 0)] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(sources, 0), cmap='plasma') plt.title(\"Two Source Interference Pattern\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show() \ud83d\udd3a Triangle Interference Pattern # Equilateral triangle sources r = 2 triangle_sources = [(r*np.cos(\u03b8), r*np.sin(\u03b8)) for \u03b8 in [0, 2*np.pi/3, 4*np.pi/3]] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(triangle_sources, 0), cmap='coolwarm') plt.title(\"Triangle Source Interference\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show() \ud83d\udd37 Pentagon Interference Pattern # Pentagon sources r = 2 pentagon_sources = [(r*np.cos(\u03b8), r*np.sin(\u03b8)) for \u03b8 in np.linspace(0, 2*np.pi, 5, endpoint=False)] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(pentagon_sources, 0), cmap='cividis') plt.title(\"Pentagon Source Interference\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show() \ud83c\udfa5 Animation (GIF) of Wave Interference import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import HTML, Image import base64 import os # Wave parameters A = 1 f = 1 \u03bb = 1 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) def wave_from_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 return A * np.cos(k * R - \u03c9 * t + \u03c6) def total_wave(sources, t): return sum(wave_from_source(x0, y0, t) for (x0, y0) in sources) # Pentagon source example r = 2 sources = [(r * np.cos(theta), r * np.sin(theta)) for theta in np.linspace(0, 2*np.pi, 5, endpoint=False)] # Create animation fig, ax = plt.subplots(figsize=(6,6)) cax = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', animated=True) fig.colorbar(cax, ax=ax, label='Amplitude') ax.set_title(\"Wave Interference Animation\") def update(frame): t = frame * 0.1 Z = total_wave(sources, t) cax.set_array(Z) ax.set_title(f\"t = {t:.2f} s\") return [cax] ani = FuncAnimation(fig, update, frames=60, blit=True) # Save GIF gif_path = \"wave_interference.gif\" ani.save(gif_path, writer=PillowWriter(fps=10)) plt.close() # Display GIF with open(gif_path, \"rb\") as f: data = f.read() data_url = \"data:image/gif;base64,\" + base64.b64encode(data).decode() display(HTML(f'<img src=\"{data_url}\" width=400>')) # Optional download link from google.colab import files files.download(gif_path) \ud83e\udde0 Observations & Analysis \u2705 Constructive Interference: Occurs when wave crests from different sources meet \u2014 resulting in higher amplitude . \u274c Destructive Interference: Occurs when a crest meets a trough \u2014 resulting in near-zero displacement . Single Source: Concentric circular ripples. Two Sources: Alternating bands of constructive/destructive interference. Triangle/Pentagon: Symmetric floral patterns due to coherent superposition \u2014 more complex as sources increase. \u2705 Conclusion This simulation visually captures the essence of wave interference and superposition principles using simple mathematical models. As more sources are added in symmetrical arrangements, the complexity and beauty of the patterns grow \u2014 reinforcing the link between geometry and physics.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"Simulating Wave Superposition from Point Sources in Regular Polygons","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources meet and combine. On a water surface, these patterns are easy to visualize as ripples intersect. This project explores how multiple wave sources positioned at the vertices of a regular polygon create beautiful and informative interference patterns. We study this using: Mathematical modeling of wave propagation Superposition of wave equations Visualizations using heatmaps and animations","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-model","text":"A circular wave on the water surface from a source at \\((x_0, y_0)\\) is described by: \\[ n(x, y, t) = A \\cos(kr - \\omega t + \\phi) \\] Where: \\(A\\) : Amplitude (same for all) \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance to the source \\(\\phi\\) : Initial phase (constant across sources)","title":"\ud83d\udcd0 Wave Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-setup","text":"We'll simulate wave patterns for: One source Two sources Multiple sources forming triangle and pentagon","title":"\ud83e\uddea Python Simulation Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-core-functions","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.animation import FuncAnimation, PillowWriter # Wave parameters A = 1 # Amplitude f = 1 # Frequency (Hz) \u03bb = 1 # Wavelength k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Phase # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) def wave_from_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid zero division return A * np.cos(k * R - \u03c9 * t + \u03c6) def total_wave(sources, t): return sum(wave_from_source(x0, y0, t) for (x0, y0) in sources)","title":"\ud83e\udde0 Python Code: Core Functions"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualizing-a-single-source","text":"plt.figure(figsize=(6,5)) plt.contourf(X, Y, wave_from_source(0, 0, 0), cmap='viridis') plt.title(\"Single Source Interference Pattern\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show()","title":"\ud83c\udf0a Visualizing a Single Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#two-sources-interference","text":"sources = [(-1.5, 0), (1.5, 0)] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(sources, 0), cmap='plasma') plt.title(\"Two Source Interference Pattern\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show()","title":"\ud83c\udf0a Two Sources Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#triangle-interference-pattern","text":"# Equilateral triangle sources r = 2 triangle_sources = [(r*np.cos(\u03b8), r*np.sin(\u03b8)) for \u03b8 in [0, 2*np.pi/3, 4*np.pi/3]] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(triangle_sources, 0), cmap='coolwarm') plt.title(\"Triangle Source Interference\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show()","title":"\ud83d\udd3a Triangle Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#pentagon-interference-pattern","text":"# Pentagon sources r = 2 pentagon_sources = [(r*np.cos(\u03b8), r*np.sin(\u03b8)) for \u03b8 in np.linspace(0, 2*np.pi, 5, endpoint=False)] plt.figure(figsize=(6,5)) plt.contourf(X, Y, total_wave(pentagon_sources, 0), cmap='cividis') plt.title(\"Pentagon Source Interference\") plt.colorbar(label='Wave Amplitude') plt.axis('equal') plt.show()","title":"\ud83d\udd37 Pentagon Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#_4","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#animation-gif-of-wave-interference","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import HTML, Image import base64 import os # Wave parameters A = 1 f = 1 \u03bb = 1 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 # Grid x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) def wave_from_source(x0, y0, t): R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 return A * np.cos(k * R - \u03c9 * t + \u03c6) def total_wave(sources, t): return sum(wave_from_source(x0, y0, t) for (x0, y0) in sources) # Pentagon source example r = 2 sources = [(r * np.cos(theta), r * np.sin(theta)) for theta in np.linspace(0, 2*np.pi, 5, endpoint=False)] # Create animation fig, ax = plt.subplots(figsize=(6,6)) cax = ax.imshow(np.zeros_like(X), extent=[-5, 5, -5, 5], cmap='inferno', animated=True) fig.colorbar(cax, ax=ax, label='Amplitude') ax.set_title(\"Wave Interference Animation\") def update(frame): t = frame * 0.1 Z = total_wave(sources, t) cax.set_array(Z) ax.set_title(f\"t = {t:.2f} s\") return [cax] ani = FuncAnimation(fig, update, frames=60, blit=True) # Save GIF gif_path = \"wave_interference.gif\" ani.save(gif_path, writer=PillowWriter(fps=10)) plt.close() # Display GIF with open(gif_path, \"rb\") as f: data = f.read() data_url = \"data:image/gif;base64,\" + base64.b64encode(data).decode() display(HTML(f'<img src=\"{data_url}\" width=400>')) # Optional download link from google.colab import files files.download(gif_path)","title":"\ud83c\udfa5 Animation (GIF) of Wave Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-analysis","text":"","title":"\ud83e\udde0 Observations &amp; Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs when wave crests from different sources meet \u2014 resulting in higher amplitude .","title":"\u2705 Constructive Interference:"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs when a crest meets a trough \u2014 resulting in near-zero displacement . Single Source: Concentric circular ripples. Two Sources: Alternating bands of constructive/destructive interference. Triangle/Pentagon: Symmetric floral patterns due to coherent superposition \u2014 more complex as sources increase.","title":"\u274c Destructive Interference:"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation visually captures the essence of wave interference and superposition principles using simple mathematical models. As more sources are added in symmetrical arrangements, the complexity and beauty of the patterns grow \u2014 reinforcing the link between geometry and physics.","title":"\u2705 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}